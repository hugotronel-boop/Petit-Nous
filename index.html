<meta name='viewport' content='width=device-width, initial-scale=1'/><!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LABYRINTH OS - ULTRA COLOR</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <canvas id="bg-canvas"></canvas>

    <div id="main-menu">
        <header>
            <h1>LABYRINTH</h1>
            <p style="color: var(--n-blue); font-size: 10px; letter-spacing: 4px;">SYSTEM_V3.0_ONLINE</p>
        </header>

        <div class="menu-grid">
            <button class="mode-btn btn-normal" onclick="openMode('normal')"><span>üü¶</span> MODE NORMAL</button>
            <button class="mode-btn btn-duo" onclick="openMode('fusion')"><span>üë•</span> FUSION DUO</button>
            <button class="mode-btn btn-rot" onclick="openMode('rotation')"><span>üîÑ</span> ROTATION</button>
            <button class="mode-btn btn-ecl" onclick="openMode('eclipse')"><span>üëÅÔ∏è</span> √âCLIPSE</button>
            <button class="mode-btn btn-mouv" onclick="openMode('mouv')"><span>üß©</span> MOUVANT</button>
            <button class="mode-btn btn-mem" onclick="openMode('mem')"><span>üß†</span> M√âMOIRE</button>
            <button class="mode-btn btn-coll" onclick="openMode('coll')"><span>üí∞</span> COLLECTE</button>
            <button class="mode-btn btn-sent" onclick="openMode('sent')"><span>üõ°Ô∏è</span> SENTINELLE</button>
            <button class="mode-btn btn-inv" onclick="openMode('inverse')"><span>ü™û</span> INVERS√â</button>
            <button class="mode-btn btn-ari" onclick="openMode('ariane')"><span>üß∂</span> ARIANE</button>
            <button class="mode-btn btn-tron" onclick="openMode('tron')"><span>‚ö°</span> TRON</button>
            <button class="mode-btn btn-zoom" onclick="openMode('zoom')"><span>üîç</span> ZOOM</button>
            <button class="mode-btn btn-traque" onclick="openMode('traque')"><span>üíÄ</span> TRAQUE</button>
            <button class="mode-btn" style="--btn-color: #fff;" onclick="alert('LABYRINTH OS v3.0 - R√©alis√© par Gemini')"><span>‚öôÔ∏è</span> INFOS</button>
        </div>
    </div>

    <div id="game-ui" class="game-mode" style="display: none;">
        <div class="stats-bar" id="ui-bar">
            <button class="ui-btn" onclick="quitGame()">RETOUR</button>
            <div id="ui-timer">00:00.0</div>
            <div id="status-text" style="font-size: 10px; opacity: 0.8;">INITIALISATION...</div>
            <button class="ui-btn" onclick="toggleSettings()">‚öôÔ∏è</button>
        </div>

        <div class="game-container" id="game-zone">
            <canvas id="game-canvas"></canvas>
            
            <div id="joy-base" class="joystick-base">
                <div id="joy-stick" class="joystick-stick"></div>
            </div>

            <div id="ammo-display" style="display: none;">
                MUNITIONS : <span id="ammo-count">0</span>
            </div>

            <div id="shoot-controls" style="display: none; position: absolute; bottom: 30px; right: 30px; grid-template-columns: repeat(3, 60px); gap: 15px; z-index: 9999;">
                <div></div>
                <button onmousedown="handleShoot(0, -1)" ontouchstart="handleShoot(0, -1)" 
                    style="width: 60px; height: 60px; background: rgba(0,0,0,0.6); border: 2px solid var(--bar-color); color: white; border-radius: 10px; pointer-events: auto; display: flex; align-items: center; justify-content: center; font-size: 20px;">‚ñ≤</button>
                <div></div>
                
                <button onmousedown="handleShoot(-1, 0)" ontouchstart="handleShoot(-1, 0)" 
                    style="width: 60px; height: 60px; background: rgba(0,0,0,0.6); border: 2px solid var(--bar-color); color: white; border-radius: 10px; pointer-events: auto; display: flex; align-items: center; justify-content: center; font-size: 20px;">‚óÄ</button>
                <button onmousedown="handleShoot(0, 1)" ontouchstart="handleShoot(0, 1)" 
                    style="width: 60px; height: 60px; background: rgba(0,0,0,0.6); border: 2px solid var(--bar-color); color: white; border-radius: 10px; pointer-events: auto; display: flex; align-items: center; justify-content: center; font-size: 20px;">‚ñº</button>
                <button onmousedown="handleShoot(1, 0)" ontouchstart="handleShoot(1, 0)" 
                    style="width: 60px; height: 60px; background: rgba(0,0,0,0.6); border: 2px solid var(--bar-color); color: white; border-radius: 10px; pointer-events: auto; display: flex; align-items: center; justify-content: center; font-size: 20px;">‚ñ∂</button>
            </div>
        </div>

        <div id="overlay-win" class="overlay">
            <div class="modal">
                <h2 id="win-title">SUCC√àS</h2>
                <button class="action-btn" onclick="nextLevel()">NIVEAU SUIVANT</button>
                <button class="action-btn" onclick="quitGame()">MENU</button>
            </div>
        </div>

<div id="settings-modal" class="overlay">
    <div class="modal">
        <h2>CENTRE DE PROGRESSION</h2>
        <p>S√©lectionnez un secteur :</p>
        
        <div id="levels-grid" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin: 20px 0;">
        </div>

        <button class="action-btn" onclick="hardResetProgression()" style="color: var(--n-red); font-size: 10px; border-color: var(--n-red);">R√âINITIALISER M√âMOIRE</button>
        
        <button class="action-btn" onclick="closeSettings()" style="margin-top:20px; border-color: #666; color: #999;">FERMER</button>
    </div>
</div>

        <div id="ui-arrows" class="arrow-controls" style="display: none;">
            <div class="dir-btn" style="grid-column: 2;" ontouchstart="handleInput('up')">‚ñ≤</div>
            <div class="dir-btn" style="grid-column: 1; grid-row: 2;" ontouchstart="handleInput('left')">‚óÄ</div>
            <div class="dir-btn" style="grid-column: 3; grid-row: 2;" ontouchstart="handleInput('right')">‚ñ∂</div>
            <div class="dir-btn" style="grid-column: 2; grid-row: 3;" ontouchstart="handleInput('down')">‚ñº</div>
        </div>
    </div>
    
<button onclick="backToMenu()">Retour</button>
    <script src="script.js"></script>
</body>
</html>
<style>/* === STYLES GLOBAUX === */
:root {
    --n-blue: #00f0ff; 
    --n-red: #ff003c; 
    --n-gold: #f1c40f;
    --n-purple: #9b59b6; 
    --n-green: #2ecc71; 
    --n-pink: #ff00ff;
    --n-orange: #e67e22; 
    --n-cyan: #00f0ff;
}

body { 
    margin: 0; 
    background: #000; 
    color: white; 
    font-family: 'Courier New', monospace; 
    height: 100vh; 
    overflow: hidden; 
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    touch-action: none; 
}

/* Background Canvas */
#bg-canvas { 
    position: fixed; 
    top: 0; 
    left: 0; 
    width: 100%; 
    height: 100%; 
    z-index: -1; 
}

/* === MENU PRINCIPAL === */
#main-menu {
    display: flex; 
    flex-direction: column; 
    align-items: center;
    width: 100%; 
    height: 100%; 
    overflow-y: auto; 
    position: relative; 
    z-index: 10;
    background: radial-gradient(circle at center, rgba(0, 40, 40, 0.3) 0%, #000 90%);
}

header { text-align: center; padding: 40px 10px; }
h1 { font-size: 2.5rem; color: #fff; text-shadow: 0 0 15px var(--n-blue); letter-spacing: 8px; margin: 0; }

.menu-grid { 
    display: grid; 
    grid-template-columns: 1fr 1fr; 
    gap: 15px; 
    width: 90%; 
    max-width: 500px; 
    padding-bottom: 50px; 
}

/* Boutons de Mode */
.mode-btn {
    --btn-color: var(--n-blue);
    background: rgba(0, 0, 0, 0.6); 
    border: 2px solid var(--btn-color);
    color: var(--btn-color); 
    padding: 18px 5px; 
    font-weight: bold; 
    font-size: 0.85rem;
    cursor: pointer; 
    border-radius: 8px; 
    transition: all 0.2s;
    text-shadow: 0 0 5px var(--btn-color); 
    box-shadow: inset 0 0 10px rgba(0,0,0,0.5), 0 0 5px var(--btn-color);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}
.mode-btn:active { transform: scale(0.92); background: var(--btn-color); color: #000; }

.btn-normal { --btn-color: var(--n-blue); grid-column: span 2; font-size: 1.1rem; }
.btn-duo { --btn-color: var(--n-purple); }
.btn-rot { --btn-color: var(--n-green); }
.btn-ecl { --btn-color: var(--n-pink); }
.btn-mouv { --btn-color: var(--n-orange); }
.btn-mem { --btn-color: #3498db; }
.btn-coll { --btn-color: var(--n-gold); }
.btn-sent { --btn-color: #95a5a6; }
.btn-inv { --btn-color: #1abc9c; }
.btn-ari { --btn-color: #e74c3c; }
.btn-tron { --btn-color: #f39c12; }
.btn-zoom { --btn-color: #2ecc71; }
.btn-traque { --btn-color: var(--n-red); }

/* === INTERFACE DE JEU === */
.game-mode { 
    display: none; 
    width: 100%; 
    height: 100%; 
    position: fixed; 
    top: 0; 
    left: 0; 
    z-index: 100; 
    flex-direction: column; 
    background: #000; 
}

.stats-bar { 
    background: rgba(0, 10, 10, 0.95); 
    padding: 10px 15px; 
    display: flex; 
    justify-content: space-between; 
    align-items: center; 
    border-bottom: 2px solid var(--bar-color, var(--n-blue));
    font-size: 0.9rem;
    z-index: 110;
}

.game-container { 
    position: relative; 
    flex-grow: 1; 
    overflow: hidden; 
    touch-action: none; 
    background: #000; 
    z-index: 1;
}

#game-canvas { 
    display: block; 
    width: 100%; 
    height: 100%; 
    z-index: 2;
}

.ui-btn { 
    background: transparent; 
    border: 1px solid currentColor; 
    color: inherit; 
    padding: 5px 12px; 
    border-radius: 4px; 
    cursor: pointer; 
    font-family: inherit; 
}

/* === OVERLAYS (Win / Settings) === */
.overlay { 
    position: absolute; 
    top: 0; 
    left: 0; 
    width: 100%; 
    height: 100%; 
    background: rgba(0,0,0,0.85); 
    display: none; 
    flex-direction: column; 
    align-items: center; 
    justify-content: center; 
    z-index: 11000; 
}
.modal { 
    background: #000; 
    padding: 25px; 
    border-radius: 10px; 
    border: 2px solid var(--bar-color, var(--n-blue)); 
    text-align: center; 
    width: 80%; 
    max-width: 300px; 
    box-shadow: 0 0 20px var(--bar-color);
}

/* Style uniforme pour les boutons d'action (y compris Progression) */
.action-btn { 
    width: 100%; 
    padding: 12px; 
    margin-top: 10px; 
    background: rgba(255, 255, 255, 0.05); 
    border: 1px solid currentColor; 
    color: inherit; 
    cursor: pointer; 
    font-weight: bold; 
    text-transform: uppercase; 
    font-family: inherit;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    border-radius: 4px;
}

.action-btn:active {
    background: white;
    color: black;
}

/* === CONTR√îLES JOYSTICK === */
.joystick-base {
    position: absolute; 
    width: 100px; 
    height: 100px; 
    background: rgba(0, 240, 255, 0.1);
    border: 2px solid var(--n-blue); 
    border-radius: 50%; 
    display: none; 
    pointer-events: none; 
    z-index: 50; 
    box-shadow: 0 0 15px var(--n-blue);
}
.joystick-stick {
    position: absolute; 
    width: 40px; 
    height: 40px; 
    background: var(--n-blue); 
    border-radius: 50%;
    top: 30px; 
    left: 30px; 
}

/* === BOUTONS DE TIR === */
#shoot-controls {
    display: none; 
    position: absolute;
    bottom: 30px;
    right: 30px; 
    grid-template-columns: repeat(3, 60px);
    gap: 15px;
    z-index: 9999 !important; 
    pointer-events: none; 
}

#shoot-controls button {
    pointer-events: auto !important; 
    width: 60px;
    height: 60px;
    background: rgba(0, 0, 0, 0.7);
    border: 2px solid var(--bar-color, #ff003c);
    color: white;
    border-radius: 10px;
    font-size: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    touch-action: manipulation;
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
}

#shoot-controls button:active {
    background: var(--bar-color, #ff003c);
    transform: scale(0.9);
}

/* Ammo display */
#ammo-display {
    position: absolute; 
    top: 70px; 
    right: 20px; 
    color: white; 
    font-family: 'Courier New', monospace; 
    z-index: 100; 
    pointer-events: none;
    text-shadow: 0 0 5px #000;
}

/* === FL√àCHES DIRECTIONNELLES (NETTOY√âES) === */
.arrow-controls {
    height: 180px; 
    background: #050505; 
    display: none;
    grid-template-columns: repeat(3, 1fr); 
    gap: 10px; 
    padding: 10px; 
    border-top: 1px solid #333;
    z-index: 1000;
}
.dir-btn { 
    border: 1px solid #555; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    font-size: 1.5rem; 
    color: #fff; 
    border-radius: 8px; 
    background: #111; 
}
#levels-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 10px;
    margin: 20px 0;
    max-height: 300px; /* Limite la hauteur de la grille */
    overflow-y: auto;  /* Ajoute un scroll si trop de niveaux */
    padding: 10px;
}
</style><script>// ==========================================
// 1. C≈íUR DU SYST√àME (Moteur & Navigation)
// ==========================================

let currentActiveMode = null;
let currentMode = null;
let controlType = 'joystick';
let startTime = 0;
let timerInterval = null;

const modeColors = {
    normal: '#00f0ff', duo: '#9b59b6', rotation: '#2ecc71', eclipse: '#ff00ff',
    mouv: '#e67e22', mem: '#3498db', coll: '#f1c40f', sent: '#ff003c',
    inverse: '#1abc9c', ariane: '#e74c3c', tron: '#f39c12', zoom: '#2ecc71', traque: '#ff003c',
    fusion: '#9b59b6'
};

// ==========================================
// 2. SYST√àME DE PROGRESSION
// ==========================================

let progression = {
    unlockedLevels: 1,
    totalLevels: 12
};

function loadProgression() {
    const savedData = JSON.parse(localStorage.getItem('mazeLevels')) || {};
    let maxLevel = 1;
    Object.values(savedData).forEach(level => {
        if (level > maxLevel) maxLevel = level;
    });
    progression.unlockedLevels = maxLevel;
}

function updateProgression() {
    let state = getActiveState();
    if (!state) return;

    // Si le niveau que tu viens de finir est le m√™me que ton max d√©bloqu√©
    if (state.level === progression.unlockedLevels && progression.unlockedLevels < progression.totalLevels) {
        progression.unlockedLevels++;
        saveLevel(currentMode, progression.unlockedLevels);
        console.log("Nouveau niveau d√©bloqu√© : " + progression.unlockedLevels);
    }
}

function saveLevel(mode, level) {
    try {
        let savedData = JSON.parse(localStorage.getItem('mazeLevels')) || {};
        if (!savedData[mode] || savedData[mode] < level) {
            savedData[mode] = level;
            localStorage.setItem('mazeLevels', JSON.stringify(savedData));
        }
    } catch (e) {
        console.error("Erreur lors de la sauvegarde:", e);
    }
}

function getLevel(mode) {
    try {
        const savedData = JSON.parse(localStorage.getItem('mazeLevels')) || {};
        return savedData[mode] || 1;
    } catch (e) {
        console.error("Erreur lors de la r√©cup√©ration:", e);
        return 1;
    }
}

// ==========================================
// 3. FONCTIONS GLOBALES
// ==========================================

function updateUI() {
    const s = getActiveState();
    if (!s) return;

    const ammoElem = document.getElementById('ammo-count');
    if (ammoElem) {
        if (currentMode === 'sent' && stateSent.ammo !== undefined) {
            ammoElem.innerText = stateSent.ammo;
        } else if (currentMode === 'traque' && stateTraque.ammo !== undefined) {
            ammoElem.innerText = stateTraque.ammo;
        }
    }

    const arianeElem = document.getElementById('ariane-percent');
    if (arianeElem && currentMode === 'ariane') {
        const percent = Math.floor((stateAriane.foundCount / stateAriane.totalEmpty) * 100) || 0;
        arianeElem.innerText = percent;
    }
}

function generateMaze(size) {
    let map = Array.from({ length: size }, () => Array(size).fill(1));
    function walk(x, y) {
        map[y][x] = 0;
        let dirs = [[0, 2], [0, -2], [2, 0], [-2, 0]].sort(() => Math.random() - 0.5);
        for (let [dx, dy] of dirs) {
            let nx = x + dx, ny = y + dy;
            if (nx > 0 && nx < size - 1 && ny > 0 && ny < size - 1 && map[ny][nx] === 1) {
                map[y + dy / 2][x + dx / 2] = 0; 
                walk(nx, ny);
            }
        }
    }
    walk(1, 1); 
    
    map[size-2][size-2] = 2;
    map[size-2][size-3] = 0;
    return map;
}

function isPathPossible(map, start, size) {
    let queue = [{x: start.x, y: start.y}];
    let visited = new Set([`${start.x},${start.y}`]);
    while(queue.length > 0) {
        let {x, y} = queue.shift();
        if(map[y][x] === 2) return true;
        for(let [dx, dy] of [[0,1],[0,-1],[1,0],[-1,0]]) {
            let nx = x + dx, ny = y + dy;
            if(ny >= 0 && ny < size && nx >= 0 && nx < size && map[ny][nx] !== 1 && !visited.has(`${nx},${ny}`)) {
                visited.add(`${nx},${ny}`);
                queue.push({x: nx, y: ny});
            }
        }
    }
    return false;
}

function mutateMap(s) {
    let tempMap = s.map.map(row => [...row]);
    let mutated = false;
    const intensity = 3 + Math.floor(s.level / 2);
    for(let i = 0; i < intensity; i++) {
        let rx = s.player.x + Math.floor(Math.random() * 7) - 3;
        let ry = s.player.y + Math.floor(Math.random() * 7) - 3;
        if(rx <= 0 || rx >= s.mapSize-1 || ry <= 0 || ry >= s.mapSize-1) continue;
        if((rx === s.player.x && ry === s.player.y) || tempMap[ry][rx] === 2) continue;
        tempMap[ry][rx] = tempMap[ry][rx] === 1 ? 0 : 1;
        mutated = true;
    }
    if(mutated && isPathPossible(tempMap, s.player, s.mapSize)) s.map = tempMap;
}

// ==========================================
// 4. LES MODES DE JEU (Logique & Rendu)
// ==========================================

// --- MODE 01 : NORMAL ---
let stateNormal = { player: { x: 1, y: 1 }, map: [], mapSize: 11, level: 1, tileSize: 80 };

function initNormal() { 
    currentMode = 'normal';
    const savedLevel = getLevel('normal');
    stateNormal.level = savedLevel || 1; 
    stateNormal.mapSize = 11; 
    resetNormal(); 
}

function resetNormal() {
    stateNormal.player = { x: 1, y: 1 };
    stateNormal.mapSize = 11 + ((stateNormal.level - 1) * 2);
    stateNormal.map = generateMaze(stateNormal.mapSize); 
    startLevelSystem(); 
}

function drawNormal(ctx) {
    const s = stateNormal; 
    const canvas = document.getElementById('game-canvas');
    const camX = canvas.width/2 - (s.player.x * s.tileSize + s.tileSize/2);
    const camY = canvas.height/2 - (s.player.y * s.tileSize + s.tileSize/2);
    ctx.save(); 
    ctx.translate(camX, camY);
    renderMap(ctx, s.map, s.mapSize, s.tileSize, "#003333", "#00f0ff");
    renderPlayer(ctx, s.player.x, s.player.y, s.tileSize, "#fff", "#00f0ff");
    ctx.restore();
}

// --- MODE 03 : ROTATION ---
let stateRotation = { player: { x: 1, y: 1 }, map: [], mapSize: 11, level: 1, tileSize: 80, angle: 0 };

function initRotation() { 
    currentMode = 'rotation';
    const savedLevel = getLevel('rotation');
    stateRotation.level = savedLevel || 1; 
    stateRotation.mapSize = 11; 
    resetRotation(); 
}

function resetRotation() { 
    stateRotation.player = { x: 1, y: 1 }; 
    stateRotation.mapSize = 11 + ((stateRotation.level - 1) * 2);
    stateRotation.map = generateMaze(stateRotation.mapSize); 
    stateRotation.angle = 0; 
    startLevelSystem(); 
}

function drawRotation(ctx) {
    const s = stateRotation; 
    const canvas = document.getElementById('game-canvas');
    if (currentMode === 'rotation') s.angle += 0.008;
    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height / 2); 
    ctx.rotate(s.angle);
    ctx.translate(-(s.player.x * s.tileSize + s.tileSize / 2), -(s.player.y * s.tileSize + s.tileSize / 2));
    renderMap(ctx, s.map, s.mapSize, s.tileSize, "#001500", "#2ecc71");
    renderPlayer(ctx, s.player.x, s.player.y, s.tileSize, "#fff", "#2ecc71");
    ctx.restore();
}

// --- MODE 04 : ECLIPSE ---
let stateEclipse = { player: { x: 1, y: 1 }, map: [], mapSize: 11, level: 1, tileSize: 80, flashTimer: 0, flashOpacity: 0 };

function initEclipse() { 
    currentMode = 'eclipse';
    const savedLevel = getLevel('eclipse');
    stateEclipse.level = savedLevel || 1; 
    stateEclipse.mapSize = 11; 
    resetEclipse(); 
}

function resetEclipse() { 
    stateEclipse.player = { x: 1, y: 1 }; 
    stateEclipse.mapSize = 11 + ((stateEclipse.level - 1) * 2);
    stateEclipse.map = generateMaze(stateEclipse.mapSize); 
    stateEclipse.flashTimer = 0; 
    startLevelSystem(); 
}

function drawEclipse(ctx) {
    const s = stateEclipse; 
    const canvas = document.getElementById('game-canvas');
    s.flashTimer += 0.02; 
    s.flashOpacity = Math.max(0, Math.sin(s.flashTimer) * 2 - 1.3); 
    const camX = canvas.width/2 - (s.player.x * s.tileSize + s.tileSize/2);
    const camY = canvas.height/2 - (s.player.y * s.tileSize + s.tileSize/2);
    ctx.save(); 
    ctx.translate(camX, camY);
    for (let y = 0; y < s.mapSize; y++) {
        for (let x = 0; x < s.mapSize; x++) {
            const tx = x * s.tileSize, ty = y * s.tileSize;
            if (s.map[y][x] === 1) {
                ctx.fillStyle = `rgba(255, 0, 255, ${s.flashOpacity * 0.3})`; 
                ctx.fillRect(tx + 2, ty + 2, s.tileSize - 4, s.tileSize - 4);
                if(s.flashOpacity > 0.1) { 
                    ctx.strokeStyle = `rgba(255, 0, 255, ${s.flashOpacity})`; 
                    ctx.strokeRect(tx + 2, ty + 2, s.tileSize - 4, s.tileSize - 4); 
                }
            } else if (s.map[y][x] === 2) {
                ctx.fillStyle = `rgba(241, 196, 15, ${s.flashOpacity + 0.3})`; 
                ctx.fillRect(tx + 5, ty + 5, s.tileSize - 10, s.tileSize - 10);
            }
        }
    }
    const pX = s.player.x * s.tileSize + s.tileSize/2, pY = s.player.y * s.tileSize + s.tileSize/2;
    const grad = ctx.createRadialGradient(pX, pY, 0, pX, pY, s.tileSize * 1.8);
    grad.addColorStop(0, 'rgba(255, 0, 255, 0.4)'); 
    grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = grad; 
    ctx.beginPath(); 
    ctx.arc(pX, pY, s.tileSize * 1.8, 0, Math.PI*2); 
    ctx.fill();
    renderPlayer(ctx, s.player.x, s.player.y, s.tileSize, "#fff", "#ff00ff");
    ctx.restore();
    if (s.flashOpacity <= 0) { 
        ctx.fillStyle = "rgba(0,0,0,0.85)"; 
        ctx.fillRect(0, 0, canvas.width, canvas.height); 
    }
}

// --- MODE 05 : MOUVANT ---
let stateMouv = { player: { x: 1, y: 1 }, map: [], mapSize: 11, level: 1, tileSize: 80, lastMutation: 0 };

function initMouv() { 
    currentMode = 'mouv';
    const savedLevel = getLevel('mouv');
    stateMouv.level = savedLevel || 1; 
    stateMouv.mapSize = 11; 
    resetMouv(); 
}

function resetMouv() { 
    stateMouv.player = { x: 1, y: 1 }; 
    stateMouv.mapSize = 11 + ((stateMouv.level - 1) * 2);
    stateMouv.map = generateMaze(stateMouv.mapSize); 
    stateMouv.lastMutation = Date.now(); 
    startLevelSystem(); 
}

function drawMouv(ctx) {
    const s = stateMouv; 
    const canvas = document.getElementById('game-canvas');
    if(Date.now() - s.lastMutation > 1500) { 
        mutateMap(s); 
        s.lastMutation = Date.now(); 
    }
    const camX = canvas.width/2 - (s.player.x * s.tileSize + s.tileSize/2);
    const camY = canvas.height/2 - (s.player.y * s.tileSize + s.tileSize/2);
    ctx.save(); 
    ctx.translate(camX, camY);
    renderMap(ctx, s.map, s.mapSize, s.tileSize, "#001a1a", "#00f0ff");
    renderPlayer(ctx, s.player.x, s.player.y, s.tileSize, "#fff", "#00f0ff");
    ctx.restore();
}

// --- MODE 06 : M√âMOIRE ---
let stateMem = { player: { x: 1, y: 1 }, map: [], mapSize: 9, level: 1, tileSize: 0, isDark: false, lastWallHit: { x: -1, y: -1, time: 0 }, memoryTimeLeft: 5 };

function initMem() { 
    currentMode = 'mem';
    const savedLevel = getLevel('mem');
    stateMem.level = savedLevel || 1; 
    stateMem.mapSize = 9; 
    resetMem(); 
}

function resetMem() {
    stateMem.player = { x: 1, y: 1 };
    stateMem.mapSize = 9 + ((stateMem.level - 1) * 2);
    stateMem.map = generateMaze(stateMem.mapSize);
    stateMem.isDark = false;
    stateMem.memoryTimeLeft = 5;
    
    const status = document.getElementById('status-text');
    if(status) status.innerText = "M√âMORISATION...";
    
    let timer = setInterval(() => {
        stateMem.memoryTimeLeft--;
        if(stateMem.memoryTimeLeft <= 0) {
            clearInterval(timer);
            stateMem.isDark = true;
            startLevelSystem();
        }
    }, 1000);
}

function drawMem(ctx) {
    const s = stateMem;
    const canvas = document.getElementById('game-canvas');
    s.tileSize = Math.min(canvas.width, canvas.height) / s.mapSize;

    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const camX = canvas.width/2 - (s.player.x * s.tileSize + s.tileSize/2);
    const camY = canvas.height/2 - (s.player.y * s.tileSize + s.tileSize/2);
    
    ctx.save();
    ctx.translate(camX, camY);

    for (let y = 0; y < s.mapSize; y++) {
        for (let x = 0; x < s.mapSize; x++) {
            const tx = x * s.tileSize, ty = y * s.tileSize;
            if (s.map[y][x] === 1) {
                if (!s.isDark) {
                    ctx.fillStyle = "#1a0033"; 
                    ctx.fillRect(tx + 2, ty + 2, s.tileSize - 4, s.tileSize - 4);
                    ctx.strokeStyle = "#3498db"; 
                    ctx.strokeRect(tx + 4, ty + 4, s.tileSize - 8, s.tileSize - 8);
                } else if (s.lastWallHit.x === x && s.lastWallHit.y === y && Date.now() - s.lastWallHit.time < 300) {
                    ctx.fillStyle = "#ff003c"; 
                    ctx.fillRect(tx, ty, s.tileSize, s.tileSize);
                }
            } else if (s.map[y][x] === 2) {
                ctx.fillStyle = !s.isDark ? "#f1c40f" : "rgba(46, 204, 113, 0.2)";
                ctx.fillRect(tx + 5, ty + 5, s.tileSize - 10, s.tileSize - 10);
            }
        }
    }
    
    if(!s.isDark) {
        ctx.fillStyle = "#f1c40f"; 
        ctx.font = "bold 60px Courier New"; 
        ctx.textAlign = "center";
        ctx.fillText(s.memoryTimeLeft, 0, 20);
    }
    
    renderPlayer(ctx, s.player.x, s.player.y, s.tileSize, "#fff", "#3498db");
    ctx.restore();
}

// --- MODE 07 : COLLECTEUR ---
let stateColl = { 
    player: { x: 1, y: 1 }, 
    map: [], 
    mapSize: 13, 
    level: 1, 
    tileSize: 80, 
    starsCollected: 0, 
    totalStars: 3 
};

function initColl() { 
    currentMode = 'coll';
    const savedLevel = getLevel('coll');
    stateColl.level = savedLevel || 1; 
    stateColl.mapSize = 13; 
    resetColl(); 
}

function resetColl() {
    stateColl.player = { x: 1, y: 1 };
    stateColl.starsCollected = 0;
    stateColl.totalStars = 2 + stateColl.level;
    stateColl.mapSize = 11 + ((stateColl.level - 1) * 2);
    
    stateColl.map = generateMaze(stateColl.mapSize);
    
    let count = 0;
    while(count < stateColl.totalStars) {
        let rx = Math.floor(Math.random() * (stateColl.mapSize - 2)) + 1;
        let ry = Math.floor(Math.random() * (stateColl.mapSize - 2)) + 1;
        if(stateColl.map[ry][rx] === 0 && (rx !== 1 || ry !== 1)) {
            stateColl.map[ry][rx] = 3; 
            count++;
        }
    }
    
    const status = document.getElementById('status-text');
    if(status) status.innerText = `COLLECTE : 0/${stateColl.totalStars}`;
    startLevelSystem();
}

function drawColl(ctx) {
    const s = stateColl;
    const canvas = document.getElementById('game-canvas');
    const camX = canvas.width/2 - (s.player.x * s.tileSize + s.tileSize/2);
    const camY = canvas.height/2 - (s.player.y * s.tileSize + s.tileSize/2);
    
    ctx.save();
    ctx.translate(camX, camY);

    for (let y = 0; y < s.mapSize; y++) {
        for (let x = 0; x < s.mapSize; x++) {
            const tile = s.map[y][x];
            const tx = x * s.tileSize;
            const ty = y * s.tileSize;

            if (tile === 1) {
                ctx.fillStyle = "#1a1500";
                ctx.fillRect(tx + 2, ty + 2, s.tileSize - 4, s.tileSize - 4);
                ctx.strokeStyle = "rgba(241, 196, 15, 0.3)";
                ctx.strokeRect(tx + 2, ty + 2, s.tileSize - 4, s.tileSize - 4);
            } 
            else if (tile === 2) {
                if (s.starsCollected >= s.totalStars) {
                    ctx.shadowBlur = 15; 
                    ctx.shadowColor = "#2ecc71";
                    ctx.fillStyle = "#2ecc71";
                    ctx.fillRect(tx + 5, ty + 5, s.tileSize - 10, s.tileSize - 10);
                    ctx.shadowBlur = 0;
                } else {
                    ctx.strokeStyle = "#444";
                    ctx.strokeRect(tx + 10, ty + 10, s.tileSize - 20, s.tileSize - 20);
                }
            } 
            else if (tile === 3) {
                const pulse = Math.sin(Date.now() * 0.005) * 5;
                ctx.shadowBlur = 15; 
                ctx.shadowColor = "#f1c40f";
                ctx.fillStyle = "#f1c40f";
                ctx.beginPath();
                ctx.arc(tx + s.tileSize/2, ty + s.tileSize/2, 10 + pulse, 0, Math.PI*2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }
    }

    renderPlayer(ctx, s.player.x, s.player.y, s.tileSize, "#fff", "#f1c40f");
    ctx.restore();
}

// --- MODE 08 : SENTINELLE ---
let stateSent = { 
    player: { x: 1, y: 1 }, 
    map: [], 
    mapSize: 11, 
    level: 1, 
    tileSize: 80,
    enemies: [], 
    bullets: [], 
    ammo: 3,
    lastEnemyMove: 0
};

function fire(dx, dy) {
    if (currentMode !== 'sent' || stateSent.ammo <= 0) return;
    stateSent.bullets.push({ 
        x: stateSent.player.x, 
        y: stateSent.player.y, 
        dx: dx * 0.2, 
        dy: dy * 0.2 
    });
    stateSent.ammo--;
    updateUI();
}

function initSent() { 
    currentMode = 'sent';
    const savedLevel = getLevel('sent');
    stateSent.level = savedLevel || 1; 
    stateSent.mapSize = 11;
    resetSent(); 
}

function resetSent() {
    const s = stateSent;
    s.player = { x: 1, y: 1 };
    s.mapSize = 11 + ((s.level - 1) * 2);
    s.ammo = 2 + s.level;
    s.bullets = [];
    s.enemies = [];
    s.map = generateMaze(s.mapSize);
    s.lastEnemyMove = Date.now();

    const enemyCount = 2 + s.level;
    while(s.enemies.length < enemyCount) {
        let ex = Math.floor(Math.random() * (s.mapSize - 2)) + 1;
        let ey = Math.floor(Math.random() * (s.mapSize - 2)) + 1;
        if(s.map[ey][ex] === 0 && (ex > 4 || ey > 4)) {
            s.enemies.push({ 
                realX: ex, realY: ey, 
                dx: Math.random() > 0.5 ? 1 : -1, 
                dy: 0, 
                alive: true 
            });
        }
    }
    updateUI();
    startLevelSystem();
}

function updateSentLogic(s) {
    if (!s.lastEnemyMove || Date.now() - s.lastEnemyMove > 300) {
        s.enemies.forEach(en => {
            if (!en.alive) return;
            let nx = en.realX + en.dx;
            let ny = en.realY + en.dy;

            if (s.map[ny] && s.map[ny][nx] === 1) {
                const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
                const validDirs = dirs.filter(([dx, dy]) => s.map[en.realY + dy][en.realX + dx] !== 1);
                if (validDirs.length > 0) {
                    const newDir = validDirs[Math.floor(Math.random() * validDirs.length)];
                    en.dx = newDir[0]; 
                    en.dy = newDir[1];
                }
            } else {
                en.realX = nx; 
                en.realY = ny;
            }
        });
        s.lastEnemyMove = Date.now();
    }

    s.enemies.forEach(en => {
        if (en.alive && en.realX === s.player.x && en.realY === s.player.y) {
            resetSent();
        }
    });

    s.bullets.forEach((b, index) => {
        b.x += b.dx; 
        b.y += b.dy;
        if (s.map[Math.round(b.y)] && s.map[Math.round(b.y)][Math.round(b.x)] === 1) {
            s.bullets.splice(index, 1);
            return;
        }
        s.enemies.forEach(en => {
            if (en.alive && Math.sqrt(Math.pow(b.x - en.realX, 2) + Math.pow(b.y - en.realY, 2)) < 0.6) {
                en.alive = false;
                s.bullets.splice(index, 1);
            }
        });
    });
}

function drawSent(ctx) {
    const s = stateSent;
    const canvas = document.getElementById('game-canvas');
    
    updateSentLogic(s);

    const camX = canvas.width/2 - (s.player.x * s.tileSize + s.tileSize/2);
    const camY = canvas.height/2 - (s.player.y * s.tileSize + s.tileSize/2);
    
    ctx.save();
    ctx.translate(camX, camY);

    renderMap(ctx, s.map, s.mapSize, s.tileSize, "#050a0f", "#3498db");

    s.bullets.forEach(b => {
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(b.x * s.tileSize + s.tileSize/2, b.y * s.tileSize + s.tileSize/2, 5, 0, Math.PI*2);
        ctx.fill();
    });

    s.enemies.forEach(en => {
        if(!en.alive) return;
        ctx.shadowBlur = 15; 
        ctx.shadowColor = "#ff003c";
        ctx.fillStyle = "#ff003c";
        ctx.beginPath();
        ctx.arc(en.realX * s.tileSize + s.tileSize/2, en.realY * s.tileSize + s.tileSize/2, 18, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;
    });

    renderPlayer(ctx, s.player.x, s.player.y, s.tileSize, "#fff", "#3498db");
    ctx.restore();
}

// --- MODE 09 : INVERS√â ---
let stateInv = { 
    player: { x: 1, y: 1 }, 
    map: [], 
    mapSize: 11, 
    level: 1, 
    tileSize: 80 
};

function initInverse() { 
    currentMode = 'inverse';
    const savedLevel = getLevel('inv');
    stateInv.level = savedLevel || 1; 
    stateInv.mapSize = 11; 
    resetInverse(); 
}

function resetInverse() {
    stateInv.player = { x: 1, y: 1 };
    stateInv.mapSize = 11 + ((stateInv.level - 1) * 2);
    stateInv.map = generateMaze(stateInv.mapSize);
    const status = document.getElementById('status-text');
    if(status) status.innerText = "‚ö† COMMANDES_INVERS√âES";
    startLevelSystem();
}

function drawInverse(ctx) {
    const s = stateInv;
    const canvas = document.getElementById('game-canvas');
    const camX = canvas.width/2 - (s.player.x * s.tileSize + s.tileSize/2);
    const camY = canvas.height/2 - (s.player.y * s.tileSize + s.tileSize/2);
    
    ctx.save();
    ctx.translate(camX, camY);

    for (let y = 0; y < s.mapSize; y++) {
        for (let x = 0; x < s.mapSize; x++) {
            const tx = x * s.tileSize;
            const ty = y * s.tileSize;
            if (s.map[y][x] === 1) {
                ctx.fillStyle = "#0a000a";
                ctx.fillRect(tx + 2, ty + 2, s.tileSize - 4, s.tileSize - 4);
                ctx.strokeStyle = "#ff00ff";
                ctx.lineWidth = 1;
                ctx.strokeRect(tx + 2, ty + 2, s.tileSize - 4, s.tileSize - 4);
            } else if (s.map[y][x] === 2) {
                const shift = Math.random() * 3;
                ctx.fillStyle = "#00f0ff";
                ctx.shadowBlur = 15; 
                ctx.shadowColor = "#ff00ff";
                ctx.fillRect(tx + 10 + shift, ty + 10, s.tileSize - 20, s.tileSize - 20);
                ctx.shadowBlur = 0;
            }
        }
    }

    renderPlayer(ctx, s.player.x, s.player.y, s.tileSize, "#fff", "#ff00ff");
    ctx.restore();
}

// --- MODE 10 : ARIANE ---
let stateAriane = { 
    player: { x: 1, y: 1 }, 
    map: [], 
    mapSize: 13, 
    level: 1, 
    tileSize: 80,
    visited: [], 
    totalEmpty: 0, 
    foundCount: 1 
};

function initAriane() {
    currentMode = 'ariane';
    const savedLevel = getLevel('ari');
    stateAriane.level = savedLevel || 1;
    stateAriane.player = { x: 1, y: 1 };
    stateAriane.visited = ["1,1"];
    stateAriane.mapSize = 13 + ((stateAriane.level - 1) * 2);
    stateAriane.map = generateMaze(stateAriane.mapSize);
    
    stateAriane.totalEmpty = 0;
    stateAriane.map.forEach(row => row.forEach(tile => {
        if(tile === 0 || tile === 2) stateAriane.totalEmpty++;
    }));
    stateAriane.foundCount = 1;
    startLevelSystem();
}

function drawAriane(ctx) {
    const s = stateAriane;
    const canvas = document.getElementById('game-canvas');
    
    s.tileSize = 80; 
    
    const camX = canvas.width / 2 - (s.player.x * s.tileSize + s.tileSize / 2);
    const camY = canvas.height / 2 - (s.player.y * s.tileSize + s.tileSize / 2);

    ctx.save();
    ctx.translate(camX, camY);

    for (let y = 0; y < s.mapSize; y++) {
        for (let x = 0; x < s.mapSize; x++) {
            if (s.map[y][x] === 1) {
                ctx.fillStyle = "rgba(241, 196, 15, 0.05)";
                ctx.fillRect(x * s.tileSize + 2, y * s.tileSize + 2, s.tileSize - 4, s.tileSize - 4);
                ctx.strokeStyle = "#f1c40f";
                ctx.strokeRect(x * s.tileSize + 2, y * s.tileSize + 2, s.tileSize - 4, s.tileSize - 4);
            } else if (s.map[y][x] === 2) {
                ctx.fillStyle = "#2ecc71";
                ctx.shadowBlur = 15; 
                ctx.shadowColor = "#2ecc71";
                ctx.fillRect(x * s.tileSize + 5, y * s.tileSize + 5, s.tileSize - 10, s.tileSize - 10);
                ctx.shadowBlur = 0;
            }
        }
    }

    ctx.beginPath();
    ctx.strokeStyle = "#f1c40f";
    ctx.lineWidth = s.tileSize * 0.3;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    
    s.visited.forEach((pos, i) => {
        const [vx, vy] = pos.split(',').map(Number);
        const px = vx * s.tileSize + s.tileSize / 2;
        const py = vy * s.tileSize + s.tileSize / 2;
        if (i === 0) ctx.moveTo(px, py); 
        else ctx.lineTo(px, py);
    });
    ctx.stroke();

    renderPlayer(ctx, s.player.x, s.player.y, s.tileSize, "#fff", "#f1c40f");
    ctx.restore();
}

// --- MODE 11 : TRAQUEUR ---
let stateTraque = { 
    player: { x: 1, y: 1 }, 
    hunter: { x: 0, y: 0, displayX: 0, displayY: 0, stunned: 0 },
    map: [], 
    mapSize: 13, 
    level: 1, 
    tileSize: 90, 
    bullets: [], 
    ammo: 3
};

function initTraque() {
    currentMode = 'traque';
    const savedLevel = getLevel('traque');
    stateTraque.level = savedLevel || 1;
    resetTraque();
}

function resetTraque() {
    const s = stateTraque;
    s.mapSize = 11 + ((s.level - 1) * 2);
    s.player = { x: 1, y: 1 };
    s.bullets = [];
    s.ammo = 3 + Math.floor(s.level / 2);
    
    s.map = generateMaze(s.mapSize);

    s.hunter = { 
        x: s.mapSize - 3, 
        y: s.mapSize - 2, 
        displayX: s.mapSize - 3, 
        displayY: s.mapSize - 2, 
        stunned: 0 
    };
    
    updateUI();
    startLevelSystem();
}

function hunterTakeStep() {
    const s = stateTraque;
    if (currentMode !== 'traque' || Date.now() < s.hunter.stunned) return;

    let start = { x: s.hunter.x, y: s.hunter.y };
    let target = { x: s.player.x, y: s.player.y };
    
    let queue = [[start]];
    let visited = new Set([`${start.x},${start.y}`]);
    let path = [];

    while (queue.length > 0) {
        let currentPath = queue.shift();
        let lastStep = currentPath[currentPath.length - 1];

        if (lastStep.x === target.x && lastStep.y === target.y) {
            path = currentPath;
            break;
        }

        for (let [dx, dy] of [[0, 1], [0, -1], [1, 0], [-1, 0]]) {
            let next = { x: lastStep.x + dx, y: lastStep.y + dy };
            let key = `${next.x},${next.y}`;

            if (next.y >= 0 && next.y < s.mapSize && next.x >= 0 && next.x < s.mapSize &&
                s.map[next.y][next.x] !== 1 && !visited.has(key)) {
                visited.add(key);
                queue.push([...currentPath, next]);
            }
        }
    }

    if (path.length > 1) {
        s.hunter.x = path[1].x;
        s.hunter.y = path[1].y;
    }
}

function updateTraqueurLogic(s) {
    const now = Date.now();

    for (let i = s.bullets.length - 1; i >= 0; i--) {
        let b = s.bullets[i];
        b.x += b.dx; 
        b.y += b.dy;
        
        let gridX = Math.round(b.x), gridY = Math.round(b.y);
        
        if (s.map[gridY] && s.map[gridY][gridX] === 1) {
            s.bullets.splice(i, 1); 
            continue;
        }

        let distH = Math.sqrt(Math.pow(b.x - s.hunter.x, 2) + Math.pow(b.y - s.hunter.y, 2));
        if (distH < 0.6) {
            s.hunter.stunned = now + 2000;
            s.bullets.splice(i, 1); 
            continue;
        }
    }

    s.hunter.displayX += (s.hunter.x - s.hunter.displayX) * 0.15;
    s.hunter.displayY += (s.hunter.y - s.hunter.displayY) * 0.15;
    
    const distP = Math.sqrt(Math.pow(s.hunter.displayX - s.player.x, 2) + Math.pow(s.hunter.displayY - s.player.y, 2));
    if (distP < 0.45 && now > s.hunter.stunned) {
        resetTraque();
    }
}

function drawTraque(ctx) {
    const s = stateTraque;
    updateTraqueurLogic(s);
    const canvas = document.getElementById('game-canvas');
    const camX = canvas.width/2 - (s.player.x * s.tileSize + s.tileSize/2);
    const camY = canvas.height/2 - (s.player.y * s.tileSize + s.tileSize/2);
    
    ctx.save();
    ctx.translate(camX, camY);
    
    for (let y = 0; y < s.mapSize; y++) {
        for (let x = 0; x < s.mapSize; x++) {
            if (s.map[y][x] === 1) {
                ctx.fillStyle = "#200";
                ctx.fillRect(x * s.tileSize + 2, y * s.tileSize + 2, s.tileSize - 4, s.tileSize - 4);
                ctx.strokeStyle = "#ff0000";
                ctx.strokeRect(x * s.tileSize + 2, y * s.tileSize + 2, s.tileSize - 4, s.tileSize - 4);
            } else if (s.map[y][x] === 2) {
                ctx.fillStyle = "#2ecc71";
                ctx.shadowBlur = 15; 
                ctx.shadowColor = "#2ecc71";
                ctx.fillRect(x * s.tileSize + 5, y * s.tileSize + 5, s.tileSize - 10, s.tileSize - 10);
                ctx.shadowBlur = 0;
            }
        }
    }
    
    s.bullets.forEach(b => {
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(b.x * s.tileSize + s.tileSize/2, b.y * s.tileSize + s.tileSize/2, 6, 0, Math.PI*2);
        ctx.fill();
    });

    ctx.globalAlpha = s.hunter.stunned > 0 ? 0.4 : 1;
    ctx.fillStyle = s.hunter.stunned > 0 ? "#444" : "#ff003c";
    ctx.beginPath();
    ctx.arc(s.hunter.displayX * s.tileSize + s.tileSize/2, s.hunter.displayY * s.tileSize + s.tileSize/2, 22, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    renderPlayer(ctx, s.player.x, s.player.y, s.tileSize, "#fff", "#00d2ff");
    ctx.restore();
}

function fireTraque(dx, dy) {
    const s = stateTraque;
    if (currentMode !== 'traque' || s.ammo <= 0) return;
    s.bullets.push({ x: s.player.x, y: s.player.y, dx: dx * 0.25, dy: dy * 0.25 });
    s.ammo--;
    updateUI();
}

// --- MODE 12 : FUSION ---
let stateFusion = {
    players: [
        { x: 1, y: 1, color: "#3498db" },
        { x: 0, y: 0, color: "#9b59b6" }
    ],
    map: [],
    mapSize: 13,
    level: 1,
    tileSize: 70,
    isFused: false,
    exitPos: { x: 0, y: 0 },
    gameFinished: false
};

function initFusion() {
    currentMode = 'fusion';
    const savedLevel = getLevel('fusion');
    stateFusion.level = savedLevel || 1;
    resetFusion();
}

function resetFusion() {
    const s = stateFusion;
    s.mapSize = 13 + ((s.level - 1) * 2);
    s.map = generateMaze(s.mapSize);
    
    s.players[0].x = 1; 
    s.players[0].y = 1;
    s.players[1].x = s.mapSize - 2; 
    s.players[1].y = s.mapSize - 2;
    
    let center = Math.floor(s.mapSize / 2);
    s.exitPos = { x: center, y: center };
    
    s.map[center][center] = 0; 
    if (center > 0) s.map[center-1][center] = 0; 
    
    s.isFused = false;
    s.gameFinished = false;
    startLevelSystem();
}

function moveFusionPlayer(pIdx, dx, dy) {
    const s = stateFusion;
    if (s.gameFinished) return;

    let p = s.players[pIdx];
    let nx = p.x + dx;
    let ny = p.y + dy;

    if (s.map[ny] && s.map[ny][nx] !== 1) {
        p.x = nx;
        p.y = ny;
    }

    let dist = Math.abs(s.players[0].x - s.players[1].x) + Math.abs(s.players[0].y - s.players[1].y);
    
    if (dist <= 1 && !s.isFused) {
        s.isFused = true;
        s.map[s.exitPos.y][s.exitPos.x] = 2;
        const mission = document.getElementById('mission-text');
        if(mission) {
            mission.innerText = "FUSION_OK : GO_CENTER";
            mission.style.color = "#f1c40f";
        }
    }

    if (s.isFused &&
        s.players[0].x === s.exitPos.x &&
        s.players[0].y === s.exitPos.y &&
        s.players[1].x === s.exitPos.x &&
        s.players[1].y === s.exitPos.y) {
        handleVictory();
    }
}

function drawFusionHalf(ctx, pIdx, xOffset, width, s) {
    const p = s.players[pIdx];
    const canvas = document.getElementById('game-canvas');
    ctx.save();
    
    ctx.beginPath();
    ctx.rect(xOffset, 0, width, canvas.height);
    ctx.clip();

    const camX = xOffset + width/2 - (p.x * s.tileSize + s.tileSize/2);
    const camY = canvas.height/2 - (p.y * s.tileSize + s.tileSize/2);
    ctx.translate(camX, camY);

    for (let y = 0; y < s.mapSize; y++) {
        for (let x = 0; x < s.mapSize; x++) {
            if (s.map[y][x] === 1) {
                ctx.fillStyle = "#050a10";
                ctx.fillRect(x * s.tileSize + 2, y * s.tileSize + 2, s.tileSize - 4, s.tileSize - 4);
                ctx.strokeStyle = s.isFused ? "#f1c40f" : "#444";
                ctx.strokeRect(x * s.tileSize + 2, y * s.tileSize + 2, s.tileSize - 4, s.tileSize - 4);
            } else if (s.map[y][x] === 2) {
                ctx.fillStyle = "#f1c40f";
                ctx.shadowBlur = 15; 
                ctx.shadowColor = "#f1c40f";
                ctx.fillRect(x * s.tileSize + 5, y * s.tileSize + 5, s.tileSize - 10, s.tileSize - 10);
                ctx.shadowBlur = 0;
            }
        }
    }

    s.players.forEach(pl => {
        ctx.fillStyle = pl.color;
        ctx.shadowBlur = 15; 
        ctx.shadowColor = pl.color;
        ctx.beginPath();
        ctx.arc(pl.x * s.tileSize + s.tileSize/2, pl.y * s.tileSize + s.tileSize/2, 15, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    });

    ctx.restore();
}

function drawFusion(ctx) {
    const s = stateFusion;
    const canvas = document.getElementById('game-canvas');
    const half = canvas.width / 2;

    drawFusionHalf(ctx, 0, 0, half, s);
    drawFusionHalf(ctx, 1, half, half, s);

    ctx.fillStyle = s.isFused ? "#f1c40f" : "#333";
    ctx.fillRect(half - 1, 0, 2, canvas.height);
}

// ==========================================
// 5. BOUCLE DE RENDU PRINCIPALE
// ==========================================
function gameLoop() {
    if (!currentMode) return;
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    switch(currentMode) {
        case 'normal':   drawNormal(ctx);   break;
        case 'rotation': drawRotation(ctx); break;
        case 'eclipse':  drawEclipse(ctx);  break;
        case 'mouv':     drawMouv(ctx);     break;
        case 'mem':      drawMem(ctx);      break;
        case 'coll':     drawColl(ctx);     break;
        case 'sent':     drawSent(ctx);     break;
        case 'inverse':  drawInverse(ctx);  break; 
        case 'ariane':   drawAriane(ctx);   break;
        case 'traque':   drawTraque(ctx);   break;
        case 'fusion':   drawFusion(ctx);   break;
    }
    requestAnimationFrame(gameLoop);
}

// ==========================================
// 6. LOGIQUE DE NAVIGATION & VICTOIRE
// ==========================================
function openMode(mode) {
    currentMode = mode;
    document.getElementById('main-menu').style.display = 'none';
    document.getElementById('bg-canvas').style.display = 'none';
    document.getElementById('game-ui').style.display = 'flex';
  
    const ammoUI = document.getElementById('ammo-display');
    if (ammoUI) {
        ammoUI.style.display = (mode === 'sent' || mode === 'traque') ? 'block' : 'none';
    }

    const shootUI = document.getElementById('shoot-controls');
    if (shootUI) {
        shootUI.style.display = (mode === 'sent' || mode === 'traque') ? 'grid' : 'none';
    }

    document.documentElement.style.setProperty('--bar-color', modeColors[mode] || '#fff');
    const mName = "init" + mode.charAt(0).toUpperCase() + mode.slice(1);
    if (window[mName]) window[mName]();
    
    resizeCanvas(); 
    gameLoop();
}

function handleVictory() {
    clearInterval(timerInterval);
    let s = getActiveState(); 
    
    const messages = {
        'normal': "LABYRINTHE MA√éTRIS√â",
        'rotation': "ROTATION SYNCHRONIS√âE",
        'eclipse': "√âCLIPSE TERMIN√âE",
        'mouv': "MUTATIONS STABILIS√âES",
        'mem': "M√âMOIRE SYNCHRONIS√âE",
        'coll': "UNIT√âS R√âCUP√âR√âES",
        'sent': "ZONE S√âCURIS√âE",
        'inverse': "MIROIR BRIS√â",
        'ariane': "FIL D'ARIANE TERMIN√â",
        'traque': "PR√âDATEUR SEM√â",
        'fusion': "FUSION STABLE"
    };

    const winMsg = messages[currentMode] || "SYST√àME SYNCHRONIS√â";
    
    updateProgression();
    
    const titleElem = document.getElementById('win-title');
    const overlay = document.getElementById('overlay-win');
    
    if (titleElem) titleElem.innerText = winMsg;
    if (overlay) {
        overlay.style.display = 'flex';
        overlay.style.pointerEvents = 'auto';
    }
}

function nextLevel() {
    const s = getActiveState();
    if (!s) return;

    const overlay = document.getElementById('overlay-win');
    if (overlay) {
        overlay.style.display = 'none';
        overlay.style.pointerEvents = 'none';
    }

    s.level++;

    let rName = "reset" + currentMode.charAt(0).toUpperCase() + currentMode.slice(1);

    if (typeof window[rName] === 'function') {
        window[rName]();
    } else {
        console.error("Fonction de reset introuvable : " + rName);
    }
    
    startLevelSystem();
    gameLoop();
}

function getActiveState() {
    switch (currentMode) {
        case 'normal': return stateNormal;
        case 'rotation': return stateRotation;
        case 'eclipse': return stateEclipse;
        case 'mouv': return stateMouv;
        case 'mem': return stateMem;
        case 'coll': return stateColl;
        case 'sent': return stateSent;
        case 'inverse': return stateInv;
        case 'ariane': return stateAriane;
        case 'traque': return stateTraque;
        case 'fusion': return stateFusion;
        default: return null;
    }
}

function movePlayer(dx, dy) {
    let s = getActiveState();
    if (!s || !s.map) return;
    
    if (currentMode === 'inverse') {
        dx *= -1; 
        dy *= -1; 
    }

    if (currentMode === 'mem' && !s.isDark) return;

    const nx = s.player.x + dx;
    const ny = s.player.y + dy;
    const posKey = `${nx},${ny}`;

    if (s.map[ny] && s.map[ny][nx] !== 1) {
        if (currentMode === 'ariane') {
            if (s.visited.includes(posKey)) return; 
            s.visited.push(posKey);
            s.foundCount++;
            updateUI();
        }

        s.player.x = nx; 
        s.player.y = ny;

        if (currentMode === 'coll' && s.map[ny][nx] === 3) {
            s.map[ny][nx] = 0; 
            s.starsCollected++;
            const status = document.getElementById('status-text');
            if (status) status.innerText = `COLLECTE : ${s.starsCollected}/${s.totalStars}`;
        }

        if (s.map[ny][nx] === 2) {
            let canWin = true;
            if (currentMode === 'coll' && s.starsCollected < s.totalStars) {
                canWin = false;
            }

            if (canWin) {
                handleVictory();
                return;
            }
        }

        if (currentMode === 'traque') {
            hunterTakeStep(); 
        }

    } else {
        if (currentMode === 'mem' && s.isDark) {
            s.lastWallHit = { x: nx, y: ny, time: Date.now() };
        }
    }
}

function quitGame() {
    currentMode = null; 
    clearInterval(timerInterval);
    
    document.getElementById('game-ui').style.display = 'none';
    document.getElementById('overlay-win').style.display = 'none';
    document.getElementById('main-menu').style.display = 'flex';
    document.getElementById('bg-canvas').style.display = 'block';

    const shootUI = document.getElementById('shoot-controls');
    if (shootUI) shootUI.style.display = 'none';
}

// ==========================================
// 7. OUTILS DE RENDU & SYST√àME
// ==========================================
function renderMap(ctx, map, size, tSize, wallFill, wallStroke) {
    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            if (map[y][x] === 1) {
                ctx.fillStyle = wallFill; 
                ctx.fillRect(x * tSize + 2, y * tSize + 2, tSize - 4, tSize - 4);
                ctx.strokeStyle = wallStroke; 
                ctx.strokeRect(x * tSize + 2, y * tSize + 2, tSize - 4, tSize - 4);
            } else if (map[y][x] === 2) {
                ctx.fillStyle = "#f1c40f"; 
                ctx.shadowBlur = 15; 
                ctx.shadowColor = "#f1c40f";
                ctx.fillRect(x * tSize + 5, y * tSize + 5, tSize - 10, tSize - 10); 
                ctx.shadowBlur = 0;
            }
        }
    }
}

function renderPlayer(ctx, px, py, tSize, color, glow) {
    ctx.shadowBlur = 15; 
    ctx.shadowColor = glow; 
    ctx.fillStyle = color;
    ctx.beginPath(); 
    ctx.arc(px * tSize + tSize/2, py * tSize + tSize/2, 15, 0, Math.PI * 2);
    ctx.fill(); 
    ctx.shadowBlur = 0;
}

function startLevelSystem() { 
    resetTimer(); 
    startTimer(); 
}

function startTimer() {
    startTime = Date.now();
    timerInterval = setInterval(() => {
        const diff = Date.now() - startTime;
        const mins = Math.floor(diff / 60000).toString().padStart(2, '0');
        const secs = Math.floor((diff % 60000) / 1000).toString().padStart(2, '0');
        const timerElem = document.getElementById('ui-timer');
        if (timerElem) timerElem.innerText = `${mins}:${secs}`;
    }, 1000);
}

function resetTimer() { 
    clearInterval(timerInterval); 
    const timerElem = document.getElementById('ui-timer');
    if (timerElem) timerElem.innerText = "00:00"; 
}

function handleInput(dir) {
    let dx = 0, dy = 0;
    if(dir === 'up') dy = -1; 
    if(dir === 'down') dy = 1;
    if(dir === 'left') dx = -1; 
    if(dir === 'right') dx = 1;
    movePlayer(dx, dy);
}

function resizeCanvas() { 
    const c = document.getElementById('game-canvas'); 
    const z = document.getElementById('game-zone'); 
    if (c && z) { 
        c.width = z.clientWidth; 
        c.height = z.clientHeight; 
    } 
}

// ==========================================
// 8. SYST√àME DE CONTR√îLE TACTILE
// ==========================================

let stickActive = false;
let stickStartPos = { x: 0, y: 0 };
let activePIdx = 0;

const joyBase = document.getElementById('joy-base');
const joyStick = document.getElementById('joy-stick');
const gameZone = document.getElementById('game-zone');

if (gameZone) {
    gameZone.addEventListener('touchstart', (e) => {
        if (controlType !== 'joystick' || !currentMode) return;
        
        stickActive = true;
        const touch = e.touches[0];
        stickStartPos = { x: touch.clientX, y: touch.clientY };

        if (currentMode === 'fusion') {
            activePIdx = (touch.clientX < window.innerWidth / 2) ? 0 : 1;
        }

        if (joyBase) {
            joyBase.style.display = 'block';
            joyBase.style.left = `${stickStartPos.x - 50}px`;
            joyBase.style.top = `${stickStartPos.y - 50}px`;
        }
    });

    gameZone.addEventListener('touchmove', (e) => {
        if (!stickActive) return;
        e.preventDefault();

        const touch = e.touches[0];
        const dx = touch.clientX - stickStartPos.x;
        const dy = touch.clientY - stickStartPos.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (joyStick) {
            const moveX = Math.min(Math.abs(dx), 30) * Math.sign(dx);
            const moveY = Math.min(Math.abs(dy), 30) * Math.sign(dy);
            joyStick.style.transform = `translate(${moveX}px, ${moveY}px)`;
        }

        if (dist > 35) {
            let stepX = 0;
            let stepY = 0;

            if (Math.abs(dx) > Math.abs(dy)) {
                stepX = dx > 0 ? 1 : -1;
            } else {
                stepY = dy > 0 ? 1 : -1;
            }

            if (currentMode === 'fusion') {
                moveFusionPlayer(activePIdx, stepX, stepY);
            } else {
                movePlayer(stepX, stepY);
            }

            stickStartPos = { x: touch.clientX, y: touch.clientY };
            if (joyBase) {
                joyBase.style.left = `${stickStartPos.x - 50}px`;
                joyBase.style.top = `${stickStartPos.y - 50}px`;
            }
        }
    }, { passive: false });
}

window.addEventListener('touchend', () => {
    stickActive = false;
    if (joyBase) joyBase.style.display = 'none';
    if (joyStick) joyStick.style.transform = 'translate(0,0)';
});

// ==========================================
// 9. SYST√àME DE TIR ET REDIMENSIONNEMENT
// ==========================================

window.onload = function() {
    resizeCanvas();
    loadProgression();
};

window.onresize = resizeCanvas;

function handleShoot(dx, dy) {
    if (window.event) window.event.preventDefault();
    
    if (currentMode === 'sent') {
        fire(dx, dy);
    } else if (currentMode === 'traque') {
        fireTraque(dx, dy);
    }
}

// ==========================================
// 10. CENTRE DE PROGRESSION
// ==========================================

function openSettings() {
    const modal = document.getElementById('settings-modal');
    if (modal) {
        modal.style.display = 'flex';
        renderLevelsGrid();
    }
}

function closeSettings() {
    const modal = document.getElementById('settings-modal');
    if (modal) modal.style.display = 'none';
}

function toggleSettings() {
    const modal = document.getElementById('settings-modal');
    if (modal.style.display === 'flex') {
        closeSettings();
    } else {
        openSettings();
    }
}

function renderLevelsGrid() {
    const grid = document.getElementById('levels-grid');
    if (!grid) return;
    
    grid.innerHTML = '';
    let maxToShow = progression.unlockedLevels + 3;
    
    for (let i = 1; i <= maxToShow; i++) {
        const btn = document.createElement('button');
        btn.innerText = i;
        
        if (i <= progression.unlockedLevels) {
            btn.className = 'level-btn unlocked';
            btn.onclick = () => selectLevel(i);
        } else {
            btn.className = 'level-btn';
            btn.innerText = 'üîí';
            btn.disabled = true;
        }
        grid.appendChild(btn);
    }
}

function selectLevel(levelNumber) {
    let state = getActiveState();
    if (state) {
        state.level = levelNumber;
    }

    closeSettings();
    
    const rName = "reset" + currentMode.charAt(0).toUpperCase() + currentMode.slice(1);
    if (window[rName]) window[rName]();
    
    resizeCanvas();
    gameLoop();
}

function hardResetProgression() {
    if (confirm("Voulez-vous vraiment effacer toute votre progression ?")) {
        localStorage.removeItem('mazeLevels');
        progression.unlockedLevels = 1;
        renderLevelsGrid();
        alert("M√©moire r√©initialis√©e.");
    }
}

window.onclick = function(event) {
    const modal = document.getElementById('settings-modal');
    if (event.target == modal) {
        closeSettings();
    }
}
</script>
